// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MOVEMENT_MOVEMENT_H_
#define FLATBUFFERS_GENERATED_MOVEMENT_MOVEMENT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
// static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
//               FLATBUFFERS_VERSION_MINOR == 12 &&
//               FLATBUFFERS_VERSION_REVISION == 19,
//              "Non-compatible flatbuffers version included");

namespace Movement {

struct ConditionBlob;

struct MovementEntry;
struct MovementEntryBuilder;

struct MovementVector;
struct MovementVectorBuilder;

struct MovementSet;
struct MovementSetBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) ConditionBlob FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t value_;
  uint8_t cond_;
  uint8_t module_type_;
  uint8_t in_use_;
  int8_t padding0__;

 public:
  ConditionBlob()
      : value_(0),
        cond_(0),
        module_type_(0),
        in_use_(0),
        padding0__(0) {
    (void)padding0__;
  }
  ConditionBlob(uint16_t _value, uint8_t _cond, uint8_t _module_type, uint8_t _in_use)
      : value_(::flatbuffers::EndianScalar(_value)),
        cond_(::flatbuffers::EndianScalar(_cond)),
        module_type_(::flatbuffers::EndianScalar(_module_type)),
        in_use_(::flatbuffers::EndianScalar(_in_use)),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
  uint8_t cond() const {
    return ::flatbuffers::EndianScalar(cond_);
  }
  uint8_t module_type() const {
    return ::flatbuffers::EndianScalar(module_type_);
  }
  uint8_t in_use() const {
    return ::flatbuffers::EndianScalar(in_use_);
  }
};
FLATBUFFERS_STRUCT_END(ConditionBlob, 6);

struct MovementEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MovementEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOARD_ID = 4,
    VT_MODULE_TYPE = 6,
    VT_VALUE_ACTION = 8,
    VT_CONDITION = 10,
    VT_ACK = 12,
    VT_ACK_TTL_MS = 14,
    VT_POST_DELAY_MS = 16
  };
  uint16_t board_id() const {
    return GetField<uint16_t>(VT_BOARD_ID, 0);
  }
  uint8_t module_type() const {
    return GetField<uint8_t>(VT_MODULE_TYPE, 0);
  }
  uint16_t value_action() const {
    return GetField<uint16_t>(VT_VALUE_ACTION, 0);
  }
  const Movement::ConditionBlob *condition() const {
    return GetStruct<const Movement::ConditionBlob *>(VT_CONDITION);
  }
  uint8_t ack() const {
    return GetField<uint8_t>(VT_ACK, 0);
  }
  uint16_t ack_ttl_ms() const {
    return GetField<uint16_t>(VT_ACK_TTL_MS, 0);
  }
  uint16_t post_delay_ms() const {
    return GetField<uint16_t>(VT_POST_DELAY_MS, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_BOARD_ID, 2) &&
           VerifyField<uint8_t>(verifier, VT_MODULE_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_VALUE_ACTION, 2) &&
           VerifyField<Movement::ConditionBlob>(verifier, VT_CONDITION, 2) &&
           VerifyField<uint8_t>(verifier, VT_ACK, 1) &&
           VerifyField<uint16_t>(verifier, VT_ACK_TTL_MS, 2) &&
           VerifyField<uint16_t>(verifier, VT_POST_DELAY_MS, 2) &&
           verifier.EndTable();
  }
};

struct MovementEntryBuilder {
  typedef MovementEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_board_id(uint16_t board_id) {
    fbb_.AddElement<uint16_t>(MovementEntry::VT_BOARD_ID, board_id, 0);
  }
  void add_module_type(uint8_t module_type) {
    fbb_.AddElement<uint8_t>(MovementEntry::VT_MODULE_TYPE, module_type, 0);
  }
  void add_value_action(uint16_t value_action) {
    fbb_.AddElement<uint16_t>(MovementEntry::VT_VALUE_ACTION, value_action, 0);
  }
  void add_condition(const Movement::ConditionBlob *condition) {
    fbb_.AddStruct(MovementEntry::VT_CONDITION, condition);
  }
  void add_ack(uint8_t ack) {
    fbb_.AddElement<uint8_t>(MovementEntry::VT_ACK, ack, 0);
  }
  void add_ack_ttl_ms(uint16_t ack_ttl_ms) {
    fbb_.AddElement<uint16_t>(MovementEntry::VT_ACK_TTL_MS, ack_ttl_ms, 0);
  }
  void add_post_delay_ms(uint16_t post_delay_ms) {
    fbb_.AddElement<uint16_t>(MovementEntry::VT_POST_DELAY_MS, post_delay_ms, 0);
  }
  explicit MovementEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MovementEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MovementEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MovementEntry> CreateMovementEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t board_id = 0,
    uint8_t module_type = 0,
    uint16_t value_action = 0,
    const Movement::ConditionBlob *condition = nullptr,
    uint8_t ack = 0,
    uint16_t ack_ttl_ms = 0,
    uint16_t post_delay_ms = 0) {
  MovementEntryBuilder builder_(_fbb);
  builder_.add_condition(condition);
  builder_.add_post_delay_ms(post_delay_ms);
  builder_.add_ack_ttl_ms(ack_ttl_ms);
  builder_.add_value_action(value_action);
  builder_.add_board_id(board_id);
  builder_.add_ack(ack);
  builder_.add_module_type(module_type);
  return builder_.Finish();
}

struct MovementVector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MovementVectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_MOVEMENTS = 6
  };
  uint8_t key() const {
    return GetField<uint8_t>(VT_KEY, 0);
  }
  bool KeyCompareLessThan(const MovementVector * const o) const {
    return key() < o->key();
  }
  int KeyCompareWithValue(uint8_t _key) const {
    return static_cast<int>(key() > _key) - static_cast<int>(key() < _key);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementEntry>> *movements() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementEntry>> *>(VT_MOVEMENTS);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEY, 1) &&
           VerifyOffset(verifier, VT_MOVEMENTS) &&
           verifier.VerifyVector(movements()) &&
           verifier.VerifyVectorOfTables(movements()) &&
           verifier.EndTable();
  }
};

struct MovementVectorBuilder {
  typedef MovementVector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(uint8_t key) {
    fbb_.AddElement<uint8_t>(MovementVector::VT_KEY, key, 0);
  }
  void add_movements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementEntry>>> movements) {
    fbb_.AddOffset(MovementVector::VT_MOVEMENTS, movements);
  }
  explicit MovementVectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MovementVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MovementVector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MovementVector> CreateMovementVector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementEntry>>> movements = 0) {
  MovementVectorBuilder builder_(_fbb);
  builder_.add_movements(movements);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MovementVector> CreateMovementVectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t key = 0,
    const std::vector<::flatbuffers::Offset<Movement::MovementEntry>> *movements = nullptr) {
  auto movements__ = movements ? _fbb.CreateVector<::flatbuffers::Offset<Movement::MovementEntry>>(*movements) : 0;
  return Movement::CreateMovementVector(
      _fbb,
      key,
      movements__);
}

struct MovementSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MovementSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOVEMENT_MAP = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementVector>> *movement_map() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementVector>> *>(VT_MOVEMENT_MAP);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MOVEMENT_MAP) &&
           verifier.VerifyVector(movement_map()) &&
           verifier.VerifyVectorOfTables(movement_map()) &&
           verifier.EndTable();
  }
};

struct MovementSetBuilder {
  typedef MovementSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_movement_map(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementVector>>> movement_map) {
    fbb_.AddOffset(MovementSet::VT_MOVEMENT_MAP, movement_map);
  }
  explicit MovementSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MovementSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MovementSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MovementSet> CreateMovementSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Movement::MovementVector>>> movement_map = 0) {
  MovementSetBuilder builder_(_fbb);
  builder_.add_movement_map(movement_map);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MovementSet> CreateMovementSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<Movement::MovementVector>> *movement_map = nullptr) {
  auto movement_map__ = movement_map ? _fbb.CreateVectorOfSortedTables<Movement::MovementVector>(movement_map) : 0;
  return Movement::CreateMovementSet(
      _fbb,
      movement_map__);
}

inline const Movement::MovementSet *GetMovementSet(const void *buf) {
  return ::flatbuffers::GetRoot<Movement::MovementSet>(buf);
}

inline const Movement::MovementSet *GetSizePrefixedMovementSet(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Movement::MovementSet>(buf);
}

template <bool B = false>
inline bool VerifyMovementSetBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<Movement::MovementSet>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedMovementSetBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<Movement::MovementSet>(nullptr);
}

inline void FinishMovementSetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Movement::MovementSet> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMovementSetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Movement::MovementSet> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Movement

#endif  // FLATBUFFERS_GENERATED_MOVEMENT_MOVEMENT_H_
