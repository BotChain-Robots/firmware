// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONFIGMESSAGE_MESSAGING_H_
#define FLATBUFFERS_GENERATED_CONFIGMESSAGE_MESSAGING_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
//static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
//              FLATBUFFERS_VERSION_MINOR == 2 &&
//              FLATBUFFERS_VERSION_REVISION == 10,
//             "Non-compatible flatbuffers version included");

namespace Messaging {

struct I32Value;
struct I32ValueBuilder;

struct U32Value;
struct U32ValueBuilder;

struct I64Value;
struct I64ValueBuilder;

struct U64Value;
struct U64ValueBuilder;

struct StringValue;
struct StringValueBuilder;

struct BlobValue;
struct BlobValueBuilder;

struct ConfigMessage;
struct ConfigMessageBuilder;

enum EntryType : int8_t {
  EntryType_NONE = 0,
  EntryType_I32 = 1,
  EntryType_U32 = 2,
  EntryType_I64 = 3,
  EntryType_U64 = 4,
  EntryType_STRING = 5,
  EntryType_BLOB = 6,
  EntryType_MIN = EntryType_NONE,
  EntryType_MAX = EntryType_BLOB
};

inline const EntryType (&EnumValuesEntryType())[7] {
  static const EntryType values[] = {
    EntryType_NONE,
    EntryType_I32,
    EntryType_U32,
    EntryType_I64,
    EntryType_U64,
    EntryType_STRING,
    EntryType_BLOB
  };
  return values;
}

inline const char * const *EnumNamesEntryType() {
  static const char * const names[8] = {
    "NONE",
    "I32",
    "U32",
    "I64",
    "U64",
    "STRING",
    "BLOB",
    nullptr
  };
  return names;
}

inline const char *EnumNameEntryType(EntryType e) {
  if (::flatbuffers::IsOutRange(e, EntryType_NONE, EntryType_BLOB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEntryType()[index];
}

enum NvsValue : uint8_t {
  NvsValue_NONE = 0,
  NvsValue_I32Value = 1,
  NvsValue_U32Value = 2,
  NvsValue_I64Value = 3,
  NvsValue_U64Value = 4,
  NvsValue_StringValue = 5,
  NvsValue_BlobValue = 6,
  NvsValue_MIN = NvsValue_NONE,
  NvsValue_MAX = NvsValue_BlobValue
};

inline const NvsValue (&EnumValuesNvsValue())[7] {
  static const NvsValue values[] = {
    NvsValue_NONE,
    NvsValue_I32Value,
    NvsValue_U32Value,
    NvsValue_I64Value,
    NvsValue_U64Value,
    NvsValue_StringValue,
    NvsValue_BlobValue
  };
  return values;
}

inline const char * const *EnumNamesNvsValue() {
  static const char * const names[8] = {
    "NONE",
    "I32Value",
    "U32Value",
    "I64Value",
    "U64Value",
    "StringValue",
    "BlobValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameNvsValue(NvsValue e) {
  if (::flatbuffers::IsOutRange(e, NvsValue_NONE, NvsValue_BlobValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNvsValue()[index];
}

template<typename T> struct NvsValueTraits {
  static const NvsValue enum_value = NvsValue_NONE;
};

template<> struct NvsValueTraits<Messaging::I32Value> {
  static const NvsValue enum_value = NvsValue_I32Value;
};

template<> struct NvsValueTraits<Messaging::U32Value> {
  static const NvsValue enum_value = NvsValue_U32Value;
};

template<> struct NvsValueTraits<Messaging::I64Value> {
  static const NvsValue enum_value = NvsValue_I64Value;
};

template<> struct NvsValueTraits<Messaging::U64Value> {
  static const NvsValue enum_value = NvsValue_U64Value;
};

template<> struct NvsValueTraits<Messaging::StringValue> {
  static const NvsValue enum_value = NvsValue_StringValue;
};

template<> struct NvsValueTraits<Messaging::BlobValue> {
  static const NvsValue enum_value = NvsValue_BlobValue;
};

bool VerifyNvsValue(::flatbuffers::Verifier &verifier, const void *obj, NvsValue type);
bool VerifyNvsValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct I32Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef I32ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct I32ValueBuilder {
  typedef I32Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(I32Value::VT_VALUE, value, 0);
  }
  explicit I32ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<I32Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<I32Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<I32Value> CreateI32Value(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  I32ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct U32Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef U32ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct U32ValueBuilder {
  typedef U32Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(U32Value::VT_VALUE, value, 0);
  }
  explicit U32ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<U32Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<U32Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<U32Value> CreateU32Value(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  U32ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct I64Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef I64ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct I64ValueBuilder {
  typedef I64Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(I64Value::VT_VALUE, value, 0);
  }
  explicit I64ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<I64Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<I64Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<I64Value> CreateI64Value(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  I64ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct U64Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef U64ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct U64ValueBuilder {
  typedef U64Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(U64Value::VT_VALUE, value, 0);
  }
  explicit U64ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<U64Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<U64Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<U64Value> CreateU64Value(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  U64ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct StringValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringValueBuilder {
  typedef StringValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringValue::VT_VALUE, value);
  }
  explicit StringValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringValue> CreateStringValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringValue> CreateStringValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Messaging::CreateStringValue(
      _fbb,
      value__);
}

struct BlobValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlobValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct BlobValueBuilder {
  typedef BlobValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(BlobValue::VT_VALUE, value);
  }
  explicit BlobValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlobValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlobValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlobValue> CreateBlobValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0) {
  BlobValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BlobValue> CreateBlobValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Messaging::CreateBlobValue(
      _fbb,
      value__);
}

struct ConfigMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConfigMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_TYPE = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  Messaging::EntryType type() const {
    return static_cast<Messaging::EntryType>(GetField<int8_t>(VT_TYPE, 0));
  }
  Messaging::NvsValue value_type() const {
    return static_cast<Messaging::NvsValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Messaging::I32Value *value_as_I32Value() const {
    return value_type() == Messaging::NvsValue_I32Value ? static_cast<const Messaging::I32Value *>(value()) : nullptr;
  }
  const Messaging::U32Value *value_as_U32Value() const {
    return value_type() == Messaging::NvsValue_U32Value ? static_cast<const Messaging::U32Value *>(value()) : nullptr;
  }
  const Messaging::I64Value *value_as_I64Value() const {
    return value_type() == Messaging::NvsValue_I64Value ? static_cast<const Messaging::I64Value *>(value()) : nullptr;
  }
  const Messaging::U64Value *value_as_U64Value() const {
    return value_type() == Messaging::NvsValue_U64Value ? static_cast<const Messaging::U64Value *>(value()) : nullptr;
  }
  const Messaging::StringValue *value_as_StringValue() const {
    return value_type() == Messaging::NvsValue_StringValue ? static_cast<const Messaging::StringValue *>(value()) : nullptr;
  }
  const Messaging::BlobValue *value_as_BlobValue() const {
    return value_type() == Messaging::NvsValue_BlobValue ? static_cast<const Messaging::BlobValue *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyNvsValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Messaging::I32Value *ConfigMessage::value_as<Messaging::I32Value>() const {
  return value_as_I32Value();
}

template<> inline const Messaging::U32Value *ConfigMessage::value_as<Messaging::U32Value>() const {
  return value_as_U32Value();
}

template<> inline const Messaging::I64Value *ConfigMessage::value_as<Messaging::I64Value>() const {
  return value_as_I64Value();
}

template<> inline const Messaging::U64Value *ConfigMessage::value_as<Messaging::U64Value>() const {
  return value_as_U64Value();
}

template<> inline const Messaging::StringValue *ConfigMessage::value_as<Messaging::StringValue>() const {
  return value_as_StringValue();
}

template<> inline const Messaging::BlobValue *ConfigMessage::value_as<Messaging::BlobValue>() const {
  return value_as_BlobValue();
}

struct ConfigMessageBuilder {
  typedef ConfigMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(ConfigMessage::VT_KEY, key);
  }
  void add_type(Messaging::EntryType type) {
    fbb_.AddElement<int8_t>(ConfigMessage::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_value_type(Messaging::NvsValue value_type) {
    fbb_.AddElement<uint8_t>(ConfigMessage::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(ConfigMessage::VT_VALUE, value);
  }
  explicit ConfigMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConfigMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConfigMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConfigMessage> CreateConfigMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    Messaging::EntryType type = Messaging::EntryType_NONE,
    Messaging::NvsValue value_type = Messaging::NvsValue_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ConfigMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConfigMessage> CreateConfigMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    Messaging::EntryType type = Messaging::EntryType_NONE,
    Messaging::NvsValue value_type = Messaging::NvsValue_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return Messaging::CreateConfigMessage(
      _fbb,
      key__,
      type,
      value_type,
      value);
}

inline bool VerifyNvsValue(::flatbuffers::Verifier &verifier, const void *obj, NvsValue type) {
  switch (type) {
    case NvsValue_NONE: {
      return true;
    }
    case NvsValue_I32Value: {
      auto ptr = reinterpret_cast<const Messaging::I32Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NvsValue_U32Value: {
      auto ptr = reinterpret_cast<const Messaging::U32Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NvsValue_I64Value: {
      auto ptr = reinterpret_cast<const Messaging::I64Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NvsValue_U64Value: {
      auto ptr = reinterpret_cast<const Messaging::U64Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NvsValue_StringValue: {
      auto ptr = reinterpret_cast<const Messaging::StringValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NvsValue_BlobValue: {
      auto ptr = reinterpret_cast<const Messaging::BlobValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyNvsValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNvsValue(
        verifier,  values->Get(i), types->GetEnum<NvsValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const Messaging::ConfigMessage *GetConfigMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Messaging::ConfigMessage>(buf);
}

inline const Messaging::ConfigMessage *GetSizePrefixedConfigMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Messaging::ConfigMessage>(buf);
}

inline bool VerifyConfigMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Messaging::ConfigMessage>(nullptr);
}

inline bool VerifySizePrefixedConfigMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Messaging::ConfigMessage>(nullptr);
}

inline void FinishConfigMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Messaging::ConfigMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedConfigMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Messaging::ConfigMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Messaging

#endif  // FLATBUFFERS_GENERATED_CONFIGMESSAGE_MESSAGING_H_
