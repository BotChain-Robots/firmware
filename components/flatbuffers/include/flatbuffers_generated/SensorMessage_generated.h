// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SENSORMESSAGE_MESSAGING_H_
#define FLATBUFFERS_GENERATED_SENSORMESSAGE_MESSAGING_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
// static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
//               FLATBUFFERS_VERSION_MINOR == 2 &&
//               FLATBUFFERS_VERSION_REVISION == 10,
//              "Non-compatible flatbuffers version included");

namespace Messaging {

struct Angle;
struct AngleBuilder;

struct SensorMessage;
struct SensorMessageBuilder;

enum SensorValue : uint8_t {
  SensorValue_NONE = 0,
  SensorValue_Angle = 1,
  SensorValue_MIN = SensorValue_NONE,
  SensorValue_MAX = SensorValue_Angle
};

inline const SensorValue (&EnumValuesSensorValue())[2] {
  static const SensorValue values[] = {SensorValue_NONE, SensorValue_Angle};
  return values;
}

inline const char *const *EnumNamesSensorValue() {
  static const char *const names[3] = {"NONE", "Angle", nullptr};
  return names;
}

inline const char *EnumNameSensorValue(SensorValue e) {
  if (::flatbuffers::IsOutRange(e, SensorValue_NONE, SensorValue_Angle))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorValue()[index];
}

template <typename T> struct SensorValueTraits {
  static const SensorValue enum_value = SensorValue_NONE;
};

template <> struct SensorValueTraits<Messaging::Angle> {
  static const SensorValue enum_value = SensorValue_Angle;
};

bool VerifySensorValue(::flatbuffers::Verifier &verifier, const void *obj,
                       SensorValue type);
bool VerifySensorValueVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types);

struct Angle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AngleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const { return GetField<int16_t>(VT_VALUE, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) && verifier.EndTable();
  }
};

struct AngleBuilder {
  typedef Angle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Angle::VT_VALUE, value, 0);
  }
  explicit AngleBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Angle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Angle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Angle>
CreateAngle(::flatbuffers::FlatBufferBuilder &_fbb, int16_t value = 0) {
  AngleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct SensorMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_TYPE = 4,
    VT_VALUES = 6
  };
  const ::flatbuffers::Vector<uint8_t> *values_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUES_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values() const {
    return GetPointer<
        const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES_TYPE) &&
           verifier.VerifyVector(values_type()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifySensorValueVector(verifier, values(), values_type()) &&
           verifier.EndTable();
  }
};

struct SensorMessageBuilder {
  typedef SensorMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values_type(
      ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values_type) {
    fbb_.AddOffset(SensorMessage::VT_VALUES_TYPE, values_type);
  }
  void add_values(
      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>>
          values) {
    fbb_.AddOffset(SensorMessage::VT_VALUES, values);
  }
  explicit SensorMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorMessage> CreateSensorMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> values_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>>
        values = 0) {
  SensorMessageBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_values_type(values_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SensorMessage> CreateSensorMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *values_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *values = nullptr) {
  auto values_type__ =
      values_type ? _fbb.CreateVector<uint8_t>(*values_type) : 0;
  auto values__ =
      values ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*values) : 0;
  return Messaging::CreateSensorMessage(_fbb, values_type__, values__);
}

inline bool VerifySensorValue(::flatbuffers::Verifier &verifier,
                              const void *obj, SensorValue type) {
  switch (type) {
  case SensorValue_NONE: {
    return true;
  }
  case SensorValue_Angle: {
    auto ptr = reinterpret_cast<const Messaging::Angle *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return true;
  }
}

inline bool VerifySensorValueVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySensorValue(verifier, values->Get(i),
                           types->GetEnum<SensorValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const Messaging::SensorMessage *GetSensorMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Messaging::SensorMessage>(buf);
}

inline const Messaging::SensorMessage *
GetSizePrefixedSensorMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Messaging::SensorMessage>(buf);
}

inline bool VerifySensorMessageBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Messaging::SensorMessage>(nullptr);
}

inline bool
VerifySizePrefixedSensorMessageBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Messaging::SensorMessage>(nullptr);
}

inline void FinishSensorMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Messaging::SensorMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSensorMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Messaging::SensorMessage> root) {
  fbb.FinishSizePrefixed(root);
}

} // namespace Messaging

#endif // FLATBUFFERS_GENERATED_SENSORMESSAGE_MESSAGING_H_
