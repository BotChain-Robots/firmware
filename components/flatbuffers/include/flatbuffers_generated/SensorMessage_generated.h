// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SENSORMESSAGE_MESSAGING_H_
#define FLATBUFFERS_GENERATED_SENSORMESSAGE_MESSAGING_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
// static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
//               FLATBUFFERS_VERSION_MINOR == 2 &&
//               FLATBUFFERS_VERSION_REVISION == 10,
//              "Non-compatible flatbuffers version included");

namespace Messaging {

struct Angle;
struct AngleBuilder;

struct SensorMessage;
struct SensorMessageBuilder;

enum SensorValue : uint8_t {
  SensorValue_NONE = 0,
  SensorValue_Angle = 1,
  SensorValue_MIN = SensorValue_NONE,
  SensorValue_MAX = SensorValue_Angle
};

inline const SensorValue (&EnumValuesSensorValue())[2] {
  static const SensorValue values[] = {SensorValue_NONE, SensorValue_Angle};
  return values;
}

inline const char *const *EnumNamesSensorValue() {
  static const char *const names[3] = {"NONE", "Angle", nullptr};
  return names;
}

inline const char *EnumNameSensorValue(SensorValue e) {
  if (::flatbuffers::IsOutRange(e, SensorValue_NONE, SensorValue_Angle))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorValue()[index];
}

template <typename T> struct SensorValueTraits {
  static const SensorValue enum_value = SensorValue_NONE;
};

template <> struct SensorValueTraits<Messaging::Angle> {
  static const SensorValue enum_value = SensorValue_Angle;
};

bool VerifySensorValue(::flatbuffers::Verifier &verifier, const void *obj,
                       SensorValue type);
bool VerifySensorValueVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types);

struct Angle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AngleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const { return GetField<int16_t>(VT_VALUE, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) && verifier.EndTable();
  }
};

struct AngleBuilder {
  typedef Angle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Angle::VT_VALUE, value, 0);
  }
  explicit AngleBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Angle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Angle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Angle>
CreateAngle(::flatbuffers::FlatBufferBuilder &_fbb, int16_t value = 0) {
  AngleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct SensorMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  Messaging::SensorValue value_type() const {
    return static_cast<Messaging::SensorValue>(
        GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const { return GetPointer<const void *>(VT_VALUE); }
  template <typename T> const T *value_as() const;
  const Messaging::Angle *value_as_Angle() const {
    return value_type() == Messaging::SensorValue_Angle
               ? static_cast<const Messaging::Angle *>(value())
               : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifySensorValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const Messaging::Angle *
SensorMessage::value_as<Messaging::Angle>() const {
  return value_as_Angle();
}

struct SensorMessageBuilder {
  typedef SensorMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(Messaging::SensorValue value_type) {
    fbb_.AddElement<uint8_t>(SensorMessage::VT_VALUE_TYPE,
                             static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SensorMessage::VT_VALUE, value);
  }
  explicit SensorMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorMessage> CreateSensorMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Messaging::SensorValue value_type = Messaging::SensorValue_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  SensorMessageBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline bool VerifySensorValue(::flatbuffers::Verifier &verifier,
                              const void *obj, SensorValue type) {
  switch (type) {
  case SensorValue_NONE: {
    return true;
  }
  case SensorValue_Angle: {
    auto ptr = reinterpret_cast<const Messaging::Angle *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return true;
  }
}

inline bool VerifySensorValueVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySensorValue(verifier, values->Get(i),
                           types->GetEnum<SensorValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const Messaging::SensorMessage *GetSensorMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Messaging::SensorMessage>(buf);
}

inline const Messaging::SensorMessage *
GetSizePrefixedSensorMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Messaging::SensorMessage>(buf);
}

inline bool VerifySensorMessageBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Messaging::SensorMessage>(nullptr);
}

inline bool
VerifySizePrefixedSensorMessageBuffer(::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Messaging::SensorMessage>(nullptr);
}

inline void FinishSensorMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Messaging::SensorMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSensorMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Messaging::SensorMessage> root) {
  fbb.FinishSizePrefixed(root);
}

} // namespace Messaging

#endif // FLATBUFFERS_GENERATED_SENSORMESSAGE_MESSAGING_H_
